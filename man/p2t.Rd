% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/p2t.R
\name{p2t}
\alias{p2t}
\title{Run Shiny app to label spatial data and imagery}
\usage{
p2t(
  umap_dir,
  label_dir,
  label_key,
  label_cols,
  r_band = 4,
  g_band = 5,
  b_band = 6,
  nir_band = 7
)
}
\arguments{
\item{umap_dir}{Path to UMAP tiles.}

\item{label_dir}{Path where label data .tifs will be saved.}

\item{label_key}{A named list of integers corresponding to target label classes.}

\item{label_cols}{Color palette for representing labeled classes.}

\item{r_band}{The index of the red wavelength band. Because the umap_tile function appends
input imagery with the 3 UMAP axes at the beginning of the raster stack, add 3 to the index
of the band before pre-processing.}

\item{g_band}{The index of the green wavelength band. Because the umap_tile function appends
input imagery with the 3 UMAP axes at the beginning of the raster stack, add 3 to the index
of the band before pre-processing.}

\item{b_band}{The index of the blue wavelength band. Because the umap_tile function appends
input imagery with the 3 UMAP axes at the beginning of the raster stack, add 3 to the index
of the band before pre-processing.}

\item{nir_band}{The index of the near-infrared wavelength band. Because the umap_tile function appends
input imagery with the 3 UMAP axes at the beginning of the raster stack, add 3 to the index
of the band before pre-processing.}
}
\value{
None. Tiles are saved to label_dir.
}
\description{
Provide pt2 with a directory containing UMAP tile data, a directory
to save labeled tiles, metadata about target classes, and band indices
of imagery. The function then launches a Shiny app in which users
may label imagery by a variety of mechanisms. These label data are
saved as .tif files in which integer values correspond to
those provided in the label_key.
}
\examples{
library(paint2train)

image_dir <- tempfile()
image_url <- 'https://github.com/mosscoder/paint2train/blob/main/data/sample_4band.tif?raw=true'
download.file(url = image_url, destfile = image_dir)
tdir <- tempdir()
setwd(tdir) 
preproc_dir <- 'preproc_tiles'
umap_dir <- 'umap_tiles'
lab_dir <- 'label_tiles'
dir.create(preproc_dir)
dir.create(umap_dir)
dir.create(lab_dir)

#some test coordinates
xcoords <- c(727495,
             727919)

ycoords <- c(5175339,
             5175408)

coord_mat <- cbind(xcoords, ycoords)

ls <- 30 #how big should the tiles be, this is the side length (in units of data, meters here)
buff <- 5  #buffer in native units of CRS
cores <- ifelse(.Platform$OS.type == 'unix', #how many cores to use for preprocessing
                   parallel::detectCores() - 1,
                   1) 
umap_cores <- parallel::detectCores() - 1                  
   
                   
tile_at_coords(coords = coord_mat,
 len_side = ls,
 buffer = buff,
 out_dir = preproc_dir,
 img = image_dir,
 ncores = cores)

preproc_pipeline <- function(t, fs, b){
 ndvi_msavi(tile = t, r_band = 1, nir_band = 4)
 sobel(t, axes = 3, fill_na = TRUE)
 mean_var(t, axes = 3, f_width = fs, fill_na = TRUE)
 remove_buffer(tile = t, b = b)
}

targ_tiles <- list.files(preproc_dir, full.names = TRUE)

mclapply(FUN = preproc_pipeline, 
 X = targ_tiles, 
 mc.cores = cores, 
 fs = c(0.5, 1),
 b = buff)
 
lapply(FUN = umap_tile,
 X = targ_tiles,
 out_dir = umap_dir,
 n_threads = umap_cores, #args passed to umap
 n_sgd_threads = umap_cores, #args passed to umap
)

label_key <- list(Unknown = 0,
        `Not woody` = 1,
        `Woody` = 2)
#Establish the color  for each class for app visualization
pal <- list('royalblue',
        'tan',
        'green')

# Start the app, note that work will be saved every time the 
# label, filter, fill buttons are clicked within the app.
# Prior work saved in the label_dir will be loaded to resume labeling
p2t(umap_dir = umap_dir, 
   label_dir = lab_dir, 
   label_key = label_key, 
   label_col = pal)

}
